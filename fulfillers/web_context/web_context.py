"""WebContext fulfiller for generating web-based context and insights."""

from utils import get_lm
from signatures.web_query_generator import WebQueryGenerator
from signatures.web_context_card_signature import WebContextCardSignature
from fulfillers.base import Fulfiller
from fulfillers.models import Card, CardType
from utils.context import GlobalPreferenceContext
from utils.perplexity import PerplexitySearch, SearchResponse
from typing import List, Tuple, Optional
from abc import ABCMeta
from pathlib import Path
import dspy
import logging

logger = logging.getLogger("parallax.web_context")

dspy.configure(lm=get_lm())


# Create a combined metaclass to resolve the conflict between ABCMeta and dspy.Module's metaclass
class CombinedMeta(ABCMeta, type(dspy.Module)):
    """Combined metaclass for classes that inherit from both ABC and dspy.Module."""
    pass


class WebContext(Fulfiller, dspy.Module, metaclass=CombinedMeta):
    """
    WebContext fulfiller that generates web search queries and provides context cards.

    Uses DSPy to:
    1. Generate intelligent web search queries based on the current document
    2. Perform web searches using Perplexity to find relevant external context
    3. Analyze search results and distill them into concise context cards
    """

    def __init__(self, **kwargs):
        """Initialize the WebContext fulfiller with DSPy module setup."""
        super().__init__(**kwargs)
        logger.info("Initializing WebContext fulfiller")
        lm = get_lm()
        if lm is not None:
            logger.info("LM configured successfully")
            dspy.configure(lm=lm)
        else:
            logger.warning("No LM available for WebContext fulfiller")
        self.query_generator = dspy.Predict(WebQueryGenerator)
        self.context_card_generator = dspy.Predict(WebContextCardSignature)
        self.search_backend = PerplexitySearch()

    async def forward(
        self,
        document_text: str,
        cursor_position: Tuple[int, int],
        global_context: GlobalPreferenceContext,
        intent_label: Optional[str] = None,
        **kwargs
    ) -> List[Card]:
        """
        Forward pass for web context fulfiller - generates context cards from web searches.

        Args:
            document_text: The entire text content of the current document
            cursor_position: (line, column) position of the parser/cursor
            global_context: Global preference context containing scope root and plan path
            intent_label: Optional LLM-generated intent or label describing the query
            **kwargs: Additional parameters

        Returns:
            List of Card objects with CONTEXT type containing web-sourced insights
        """
        logger.info(f"WebContext fulfiller invoked at {cursor_position}, scope_root={global_context.scope_root}, plan_path={global_context.plan_path}")

        # Build context description
        context_description = f"Repository at {global_context.scope_root}"
        if global_context.plan_path:
            context_description += f", Plan file: {global_context.plan_path}"

        # Generate web search queries using DSPy Predict module
        logger.info("Invoking DSPy query generator")
        query_result = self.query_generator(
            current_document=document_text,
            context_description=context_description
        )

        # Log the generated queries
        if not query_result.queries:
            logger.warning("No queries generated by query generator")
            return []

        logger.info(f"Generated {len(query_result.queries)} queries: {query_result.queries}")

        # Perform searches for each query and collect all results
        all_search_responses: List[SearchResponse] = []
        for query in query_result.queries:
            logger.info(f"Executing web search for query: {query}")

            # Perform the search
            search_response: SearchResponse = self.search_backend.search(
                query=query,
                max_tokens=1024,
                temperature=0.2
            )

            # Log the search result
            logger.info(f"Search result for '{query}': success={search_response.success}")
            if search_response.error:
                logger.warning(f"Search error: {search_response.error}")

            all_search_responses.append(search_response)

        # Combine all search results into citation list format
        combined_context = self._combine_search_results(all_search_responses)
        logger.debug(f"Combined search results: {len(combined_context)} items")

        # Read plan file if available
        plan_content = ""
        if global_context.plan_path:
            try:
                plan_path = Path(global_context.plan_path)
                if plan_path.exists() and plan_path.is_file():
                    plan_content = plan_path.read_text()
                    logger.info(f"Read plan file: {global_context.plan_path} ({len(plan_content)} characters)")
                else:
                    logger.warning(f"Plan file not found or not a file: {global_context.plan_path}")
            except Exception as e:
                logger.error(f"Failed to read plan file: {e}")

        # If no plan content, use document text as fallback
        if not plan_content:
            plan_content = document_text
            logger.info("Using document text as plan content (no plan file provided)")

        # Invoke context card generator to distill web context
        logger.info("Invoking DSPy context card generator")
        card_result = self.context_card_generator(
            web_search_context=combined_context,
            current_plan=plan_content
        )

        # Convert output cards to CONTEXT cards
        cards = []
        if card_result.curated_context_cards:
            logger.info(f"Generated {len(card_result.curated_context_cards)} context cards")
            for i, card_text in enumerate(card_result.curated_context_cards, 1):
                card = Card(
                    header=f"Web Context {i}",
                    text=card_text,
                    type=CardType.CONTEXT,
                    metadata={
                        "source": "web_context",
                        "plan_path": global_context.plan_path,
                        "card_number": i
                    }
                )
                cards.append(card)
        else:
            logger.info("No context cards generated")

        logger.info(f"Generated {len(cards)} context cards")
        return cards

    def _combine_search_results(self, search_responses: List[SearchResponse]) -> List[str]:
        """
        Combine multiple SearchResponse objects into a list of citation strings.

        Args:
            search_responses: List of SearchResponse objects

        Returns:
            List of strings in format ["citation: content", ...]
        """
        if not search_responses:
            return []

        combined_results = []
        for response in search_responses:
            if response.success:
                citation_list = response.to_citation_list()
                combined_results.extend(citation_list)

        if not combined_results:
            return ["No search results available."]

        return combined_results

    async def is_available(self) -> bool:
        """Check if web context fulfiller is available."""
        from utils import get_lm
        lm_available = get_lm() is not None
        perplexity_available = self.search_backend.is_available()
        available = lm_available and perplexity_available
        logger.info(f"WebContext fulfiller availability check: LM={lm_available}, Perplexity={perplexity_available}, overall={available}")
        return available
