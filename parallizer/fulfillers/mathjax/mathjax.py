"""MathJax fulfiller for completing LaTeX equations in the active document."""

from __future__ import annotations

import logging
from abc import ABCMeta
from typing import List, Optional, Tuple

import dspy

from parallizer.fulfillers.base import Fulfiller
from parallizer.signatures.mathjax_signature import MathJaxCompletion
from parallizer.utils import get_lm
from shared.context import GlobalPreferenceContext
from shared.models import Card, CardType

logger = logging.getLogger("parallax.mathjax")


class CombinedMeta(ABCMeta, type(dspy.Module)):
    """Resolve metaclass conflicts between ABCMeta and dspy.Module."""

    pass


class MathJax(Fulfiller, dspy.Module, metaclass=CombinedMeta):
    """
    Fulfiller that locates incomplete math expressions and returns MathJax-ready LaTeX.

    The fulfiller delegates reasoning to the MathJaxCompletion DSPy signature and emits
    Math cards containing the finished equations so downstream consumers can render or
    insert them directly.
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        logger.info("Initializing MathJax fulfiller")
        lm = get_lm()
        if lm is not None:
            logger.info("LM configured successfully")
        else:
            logger.warning("No LM available for MathJax fulfiller")
        self.predictor = dspy.Predict(MathJaxCompletion)

    async def forward(
        self,
        document_text: str,
        cursor_position: Tuple[int, int],
        global_context: GlobalPreferenceContext,
        intent_label: Optional[str] = None,
        **kwargs,
    ) -> List[Card]:
        """
        Generate Math cards containing completed MathJax equations.

        Args:
            document_text: Entire document content.
            cursor_position: (line, column) tuple for the editor caret.
            global_context: Global preference context (scope root, plan path).
            intent_label: Optional label describing the user intent.

        Returns:
            List of Math cards containing MathJax equations.
        """
        logger.info(
            "MathJax fulfiller invoked at %s, scope_root=%s, plan_path=%s",
            cursor_position,
            global_context.scope_root,
            global_context.plan_path,
        )

        logger.debug("Invoking DSPy predictor for MathJax completions")
        result = self.predictor(current_document=document_text)

        cards: List[Card] = []
        if result.mathjax_equations:
            logger.info("Generated %d MathJax equations", len(result.mathjax_equations))
            for idx, equation in enumerate(result.mathjax_equations, start=1):
                metadata = {
                    "source": "mathjax",
                    "cursor_position": cursor_position,
                    "intent_label": intent_label,
                    "equation_index": idx,
                }
                card = Card(
                    header=f"Math Equation {idx}",
                    text=equation,
                    type=CardType.MATH,
                    metadata=metadata,
                )
                cards.append(card)
        else:
            logger.info("No MathJax equations generated by predictor")

        return cards

    async def is_available(self) -> bool:
        """Check if the fulfiller can be executed (requires an LM)."""
        from parallizer.utils import get_lm as refresh_lm

        available = refresh_lm() is not None
        logger.info("MathJax fulfiller availability check: %s", available)
        return available


